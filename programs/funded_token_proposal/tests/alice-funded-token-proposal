// NPM Packages
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import assert from 'assert';

const { BN } = anchor.default;
const { Keypair, PublicKey, SystemProgram } = anchor.web3;

// Constants
const LAMPORTS_PER_SOL = 1_000_000_000;
const PUBKEY_COUNT_MAX = 10_000;
const TOKEN_PROPOSAL_FACTORY_TOKEN_PROPOSALS_MAX = 100;
const TOKEN_PROPOSAL_NAME_LENGTH_MAX = 50;
const TOKEN_PROPOSAL_SYMBOL_LENGTH_MAX = 3;
const TOKEN_PROPOSAL_DESCRIPTION_LENGTH_MAX = 255;
const TOKEN_PROPOSAL_LOGO_URL_LENGTH_MAX = 127;
const TOKEN_PROPOSAL_VOTING_VOTE_UNIT_LENGTH_MAX = 10;
const USER_TOKEN_PROPOSAL_CONTRIBUTIONS_MAX = 100;

describe("Funded Token Proposal", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.FundedTokenProposal;

  // Admin
  const admin = provider.wallet;

  // Users (Alice, Bob, Chris & Diana)
  const alice = Keypair.generate();
  const bob = Keypair.generate();
  const chris = Keypair.generate();
  const diana = Keypair.generate();

  let aliceAccountId;
  let aliceBump;
  let aliceContributionAccount;
  let aliceContributionAccountId;
  let aliceContributionAmount;
  let aliceContributionBump;
  let aliceTokenProposalAccount;
  let aliceTokenProposalAccountId;
  let aliceTokenProposalBump;
  let aliceUserAccount;
  let bobAccountId;
  let bobBump;
  let bobContributionAccount;
  let bobContributionAccountId;
  let bobContributionAmount;
  let bobContributionBump;
  let bobUserAccount;
  let chrisAccountId;
  let chrisBump;
  let chrisContributionAccount;
  let chrisContributionAccountId;
  let chrisContributionBump;
  let chrisUserAccount;
  let dianaAccountId;
  let dianaBump;
  let dianaContributionAccount;
  let dianaContributionAccountId;
  let dianaContributionBump;
  let dianaUserAccount;
  let tokenProposalFactoryAccountId;
  let tokenProposalFactoryBump;

  before(async () => {
    /*
     * Airdrop to wallets.
     */
    // Alice
    await provider.connection.requestAirdrop(
      alice.publicKey,
      LAMPORTS_PER_SOL
    );

    // Bob
    await provider.connection.requestAirdrop(
      bob.publicKey,
      LAMPORTS_PER_SOL
    );

    // Chris
    await provider.connection.requestAirdrop(
      chris.publicKey,
      LAMPORTS_PER_SOL
    );

    // Diana
    await provider.connection.requestAirdrop(
      diana.publicKey,
      LAMPORTS_PER_SOL
    );

    // Generate PDA for the Token Proposal Factory account.
    [tokenProposalFactoryAccountId, tokenProposalFactoryBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode('token_proposal_factory'),
      ],
      program.programId,
    );

    /*
     * Users (Alice, Bob, Chris & Diana) accounts (PDAs)
     */
    // Alice
    [aliceAccountId, aliceBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode('user'),
        alice.publicKey.toBytes(),
      ],
      program.programId,
    );

    // Bob
    [bobAccountId, bobBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode('user'),
        bob.publicKey.toBytes(),
      ],
      program.programId,
    );

    // Chris
    [chrisAccountId, chrisBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode('user'),
        chris.publicKey.toBytes(),
      ],
      program.programId,
    );

    // Diana
    [dianaAccountId, dianaBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode('user'),
        diana.publicKey.toBytes(),
      ],
      program.programId,
    );

    // Generate PDA for Alice's Token Proposal account.
    [aliceTokenProposalAccountId, aliceTokenProposalBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode('token_proposal'),
        tokenProposalFactoryAccountId.toBytes(),
        // Initial Token Proposal Factory's Token Proposal count
        new BN(0).toBuffer('le', 4),
        alice.publicKey.toBytes(),
      ],
      program.programId,
    );

    // Generate PDA for Alice's Contribution account.
    [aliceContributionAccountId, aliceContributionBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode('contribution'),
        aliceTokenProposalAccountId.toBytes(),
        alice.publicKey.toBytes(),
      ],
      program.programId,
    );

    // Generate PDA for Bob's Contribution account.
    [bobContributionAccountId, bobContributionBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode('contribution'),
        aliceTokenProposalAccountId.toBytes(),
        bob.publicKey.toBytes(),
      ],
      program.programId,
    );

    // Generate PDA for Chris's Contribution account.
    [chrisContributionAccountId, chrisContributionBump] = await PublicKey.findProgramAddress(
      [
        anchor.utils.bytes.utf8.encode('contribution'),
        aliceTokenProposalAccountId.toBytes(),
        chris.publicKey.toBytes(),
      ],
      program.programId,
    );
  });

  let tokenProposalFactoryAccount;

  describe("Initialize the Token Proposal Factory:", () => {
    before(async () => {
      const tx = await program.methods.initializeTokenProposalFactory()
        .accounts({
          signer: admin.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProposalFactory: tokenProposalFactoryAccountId,
        })
        .rpc();

      tokenProposalFactoryAccount = await program.account.tokenProposalFactory
        .fetch(tokenProposalFactoryAccountId);
    });

    it("should create a Token Proposal Factory account.", async () => {
      assert.ok(tokenProposalFactoryAccount);
    });

    it("should set the Token Proposal Factory's admin to the admin.", async () => {
      assert.deepEqual(tokenProposalFactoryAccount.admin, admin.publicKey);
    });

    it("should set the Token Proposal Factory's Token Proposal IDs to an empty collection.", async () => {
      assert.deepEqual(tokenProposalFactoryAccount.tokenProposalIds, []);
    });
  });

  describe("Alice creates a User account:", () => {
    before(async () => {
      const tx = await program.methods.createUser()
        .accounts({
          signer: alice.publicKey,
          systemProgram: SystemProgram.programId,
          user: aliceAccountId,
        })
        .signers([alice])
        .rpc();

      aliceUserAccount = await program.account.user
        .fetch(aliceAccountId);
    });

    it("should create a User account for Alice.", async () => {
      assert.ok(aliceUserAccount);
    });

    it("should set Alice's Contribution IDs to an empty collection.", async () => {
      assert.deepEqual(aliceUserAccount.contributionIds, []);
    });

    it("should set Alice's total contributions to zero.", async () => {
      assert.equal(aliceUserAccount.totalContributions, 0);
    });
  });

  describe("Alice creates a Token Proposal for the ALICE token:", () => {
    let airdropModules;
    let fundingGoals;
    let fundingModel;
    let hardCap;
    let selectedGoals;
    let softCap;
    let token;
    let voting;

    before(async () => {
      token = {
        name: "Alice's Token",
        symbol: 'ALICE',
        description: "This is Alice's token.",
        logoUrl: 'https://alice-token.com/logo.png',
      };
      selectedGoals = {
        lp: false,
        treasury: false,
        kol: false,
        ai: false,
      };
      fundingGoals = {
        lp: 0,
        treasury: 0,
        kol: 0,
        ai: 0,
      };
      softCap = 3;
      hardCap = 3;
      fundingModel = {
        dynamicUnlock: false,
        endsEarlyOnHardCap: false,
      };
      airdropModules = {
        dropScore: false,
      };
      voting = {
        periodDays: 5,
        voteUnit: 'DAYS',
        escrowedFund: false
      };

      const tx = await program.methods
        .createTokenProposal(
          token,
          selectedGoals,
          fundingGoals,
          softCap,
          hardCap,
          fundingModel,
          airdropModules,
          voting,
        )
        .accounts({
          signer: alice.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProposal: aliceTokenProposalAccountId,
          tokenProposalFactory: tokenProposalFactoryAccountId,
        })
        .signers([alice])
        .rpc();

      aliceTokenProposalAccount = await program.account.tokenProposal
        .fetch(aliceTokenProposalAccountId);
    });

    it("should create a Token Proposal account for Alice's Token Proposal.", async () => {
      assert.ok(aliceTokenProposalAccount);
    });

    it("should set Alice Token Proposal's owner to Alice.", async () => {
      assert.deepEqual(aliceTokenProposalAccount.owner, alice.publicKey);
    });

    it("should set Alice Token Proposal's token to the token.", async () => {
      assert.deepEqual(aliceTokenProposalAccount.token, token);
    });

    it("should set Alice Token Proposal's selected goals to the selected goals.", async () => {
      assert.deepEqual(aliceTokenProposalAccount.selectedGoals, selectedGoals);
    });

    it("should set Alice Token Proposal's selected goals to the funding goals.", async () => {
      assert.deepEqual(aliceTokenProposalAccount.fundingGoals, fundingGoals);
    });

    it("should set Alice Token Proposal's soft cap to the soft cap.", async () => {
      assert.equal(aliceTokenProposalAccount.softCap, softCap);
    });

    it("should set Alice Token Proposal's hard cap to the hard cap.", async () => {
      assert.equal(aliceTokenProposalAccount.hardCap, hardCap);
    });

    it("should set Alice Token Proposal's funding model to the funding model.", async () => {
      assert.deepEqual(aliceTokenProposalAccount.fundingModel, fundingModel);
    });

    it("should set Alice Token Proposal's airdrop modules to the airdrop modules.", async () => {
      assert.deepEqual(aliceTokenProposalAccount.airdropModules, airdropModules);
    });

    it("should set Alice Token Proposal's voting to the voting.", async () => {
      assert.deepEqual(aliceTokenProposalAccount.voting, voting);
    });

    it("should set Alice Token Proposal's amount contributed to zero.", async () => {
      assert.equal(aliceTokenProposalAccount.amountContributed, 0);
    });

    it("should set Alice Token Proposal's contribution count to zero.", async () => {
      assert.equal(aliceTokenProposalAccount.contributionCount, 0);
    });

    it("should set Alice Token Proposal's ready to be finalized to false.", async () => {
      assert.equal(aliceTokenProposalAccount.readyToBeFinalized, false);
    });

    it("should set Alice Token Proposal's finalized to false.", async () => {
      assert.equal(aliceTokenProposalAccount.finalized, false);
    });

    it("should set Alice Token Proposal's completed to false.", async () => {
      assert.equal(aliceTokenProposalAccount.completed, false);
    });

    it("should not change the Token Proposal Factory's admin.", async () => {
      assert.deepEqual(tokenProposalFactoryAccount.admin, admin.publicKey);
    });

    it("should add Alice Token Proposal ID to the Token Proposal Factory's Token Proposal IDs collection.", async () => {
      const updatedTokenProposalFactoryAccount = await program.account.tokenProposalFactory
        .fetch(tokenProposalFactoryAccountId);

      assert.deepEqual(updatedTokenProposalFactoryAccount.tokenProposalIds, [aliceTokenProposalAccountId]);
    });
  });

  describe("Alice contributes to her own Token Proposal:", () => {
    before(async () => {
      aliceContributionAmount = new BN(0.1 * LAMPORTS_PER_SOL); // 0.1 SOL in lamports

      const tx = await program.methods.contributeToTokenProposal(aliceContributionAmount)
        .accounts({
          contribution: aliceContributionAccountId,
          signer: alice.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProposal: aliceTokenProposalAccountId,
          user: aliceAccountId,
        })
        .signers([alice])
        .rpc();

      // Wait for confirmation.
      await provider.connection.confirmTransaction(tx);

      aliceContributionAccount = await program.account.contribution
        .fetch(aliceContributionAccountId);

      aliceUserAccount = await program.account.user
        .fetch(aliceAccountId);

      aliceTokenProposalAccount = await program.account.tokenProposal
        .fetch(aliceTokenProposalAccountId);
    });

    it("should create a Contribution account for Alice's contribution.", async () => {
      assert.ok(aliceContributionAccount);
    });

    it("should set Alice Contribution's amount to the amount.", async () => {
      assert.equal(aliceContributionAccount.amount.toNumber(), aliceContributionAmount.toNumber());
    });

    it("should set Alice Contribution's Token Proposal ID to the Alice Token Proposal ID.", async () => {
      assert.deepEqual(aliceContributionAccount.tokenProposalId, aliceTokenProposalAccountId);
    });

    it("should set Alice Contribution's User ID to Alice ID.", async () => {
      assert.deepEqual(aliceContributionAccount.userId, aliceAccountId);
    });

    it("should add Alice Contribution ID to Alice's Contribution IDs collection.", async () => {
      const updatedAliceUserAccount = await program.account.user
        .fetch(aliceAccountId);

      assert.deepEqual(updatedAliceUserAccount.contributionIds, [aliceContributionAccountId]);
    });

    it("should add Alice Contribution's amount to Alice's total contributions.", async () => {
      assert.equal(aliceUserAccount.totalContributions.toNumber(), aliceContributionAmount.toNumber());
    });

    it("should add Alice Contribution's amount to the Alice Token Proposal's amount contributed.", async () => {
      assert.equal(aliceTokenProposalAccount.amountContributed.toNumber(), aliceContributionAmount.toNumber());
    });

    it("should increment Alice Token Proposal's contribution count", async () => {
      assert.equal(aliceTokenProposalAccount.contributionCount, 1);
    });
  });

  describe("Bob creates a User account:", () => {
    before(async () => {
      const tx = await program.methods.createUser()
        .accounts({
          signer: bob.publicKey,
          systemProgram: SystemProgram.programId,
          user: bobAccountId,
        })
        .signers([bob])
        .rpc();

      bobUserAccount = await program.account.user
        .fetch(bobAccountId);
    });

    it("should create a User account for Bob.", async () => {
      assert.ok(bobUserAccount);
    });

    it("should set Bob's Contribution IDs to an empty collection.", async () => {
      assert.deepEqual(bobUserAccount.contributionIds, []);
    });

    it("should set Bob's total contributions to zero.", async () => {
      assert.equal(bobUserAccount.totalContributions, 0);
    });
  });

  describe("Bob contributes to Alice's Token Proposal:", () => {
    before(async () => {
      bobContributionAmount = new BN(0.2 * LAMPORTS_PER_SOL); // 0.2 SOL in lamports

      const tx = await program.methods.contributeToTokenProposal(bobContributionAmount)
        .accounts({
          contribution: bobContributionAccountId,
          signer: bob.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProposal: aliceTokenProposalAccountId,
          user: bobAccountId,
        })
        .signers([bob])
        .rpc();

      // Wait for confirmation.
      await provider.connection.confirmTransaction(tx);

      bobContributionAccount = await program.account.contribution
        .fetch(bobContributionAccountId);

      bobUserAccount = await program.account.user
        .fetch(bobAccountId);

      aliceTokenProposalAccount = await program.account.tokenProposal
        .fetch(aliceTokenProposalAccountId);
    });

    it("should create a Contribution account for Bob's contribution.", async () => {
      assert.ok(bobContributionAccount);
    });

    it("should set Bob Contribution's amount to the amount.", async () => {
      assert.equal(bobContributionAccount.amount.toNumber(), bobContributionAmount.toNumber());
    });

    it("should set Bob Contribution's Token Proposal ID to the Alice Token Proposal ID.", async () => {
      assert.deepEqual(bobContributionAccount.tokenProposalId, aliceTokenProposalAccountId);
    });

    it("should set Bob Contribution's User ID to Bob ID.", async () => {
      assert.deepEqual(bobContributionAccount.userId, bobAccountId);
    });

    it("should add Bob Contribution ID to the Bob's Contribution IDs collection.", async () => {
      const updatedBobUserAccount = await program.account.user
        .fetch(bobAccountId);

      assert.deepEqual(updatedBobUserAccount.contributionIds, [bobContributionAccountId]);
    });

    it("should add Bob Contribution's amount to the Bob's total contributions.", async () => {
      assert.equal(bobUserAccount.totalContributions.toNumber(), bobContributionAmount.toNumber());
    });

    it("should add Bob Contribution's amount to the Alice Token Proposal's amount contributed.", async () => {
      assert.equal(
        aliceTokenProposalAccount.amountContributed.toNumber(),
        aliceContributionAmount.toNumber() + bobContributionAmount.toNumber()
      );
    });

    it("should increment Alice Token Proposal's contribution count", async () => {
      assert.equal(aliceTokenProposalAccount.contributionCount, 1 + 1);
    });
  });

  describe("Chris creates a User account:", () => {
    before(async () => {
      const tx = await program.methods.createUser()
        .accounts({
          signer: chris.publicKey,
          systemProgram: SystemProgram.programId,
          user: chrisAccountId,
        })
        .signers([chris])
        .rpc();

      chrisUserAccount = await program.account.user
        .fetch(chrisAccountId);
    });

    it("should create a User account for Chris.", async () => {
      assert.ok(chrisUserAccount);
    });

    it("should set Chris's Contribution IDs to an empty collection.", async () => {
      assert.deepEqual(chrisUserAccount.contributionIds, []);
    });

    it("should set Chris's total contributions to zero.", async () => {
      assert.equal(chrisUserAccount.totalContributions, 0);
    });
  });

  describe("Chris contributes to Alice's Token Proposal:", () => {
    let chrisContributionAmount;

    before(async () => {
      chrisContributionAmount = new BN(0.3 * LAMPORTS_PER_SOL); // 0.3 SOL in lamports

      const tx = await program.methods.contributeToTokenProposal(chrisContributionAmount)
        .accounts({
          contribution: chrisContributionAccountId,
          signer: chris.publicKey,
          systemProgram: SystemProgram.programId,
          tokenProposal: aliceTokenProposalAccountId,
          user: chrisAccountId,
        })
        .signers([chris])
        .rpc();

      // Wait for confirmation.
      await provider.connection.confirmTransaction(tx);

      chrisContributionAccount = await program.account.contribution
        .fetch(chrisContributionAccountId);

      chrisUserAccount = await program.account.user
        .fetch(chrisAccountId);

      aliceTokenProposalAccount = await program.account.tokenProposal
        .fetch(aliceTokenProposalAccountId);
    });

    it("should create a Contribution account for Chris's contribution.", async () => {
      assert.ok(chrisContributionAccount);
    });

    it("should set Chris Contribution's amount to the amount.", async () => {
      assert.equal(chrisContributionAccount.amount.toNumber(), chrisContributionAmount.toNumber());
    });

    it("should set Chris Contribution's Token Proposal ID to the Alice Token Proposal ID.", async () => {
      assert.deepEqual(chrisContributionAccount.tokenProposalId, aliceTokenProposalAccountId);
    });

    it("should set Chris Contribution's User ID to Chris ID.", async () => {
      assert.deepEqual(chrisContributionAccount.userId, chrisAccountId);
    });

    it("should add Chris Contribution ID to the Chris's Contribution IDs collection.", async () => {
      const updatedChrisUserAccount = await program.account.user
        .fetch(chrisAccountId);

      assert.deepEqual(updatedChrisUserAccount.contributionIds, [chrisContributionAccountId]);
    });

    it("should add Chris Contribution's amount to the Chris's total contributions.", async () => {
      assert.equal(chrisUserAccount.totalContributions.toNumber(), chrisContributionAmount.toNumber());
    });

    it("should add Chris Contribution's amount to the Alice Token Proposal's amount contributed.", async () => {
      assert.equal(
        aliceTokenProposalAccount.amountContributed.toNumber(),
        aliceContributionAmount.toNumber() + bobContributionAmount.toNumber() + chrisContributionAmount.toNumber()
      );
    });

    it("should increment Alice Token Proposal's contribution count", async () => {
      assert.equal(aliceTokenProposalAccount.contributionCount, 1 + 1 + 1);
    });
  });

  describe("Diana creates a User account:", () => {
    before(async () => {
      const tx = await program.methods.createUser()
        .accounts({
          signer: diana.publicKey,
          systemProgram: SystemProgram.programId,
          user: dianaAccountId,
        })
        .signers([diana])
        .rpc();

      dianaUserAccount = await program.account.user
        .fetch(dianaAccountId);
    });

    it("should create a User account for Diana.", async () => {
      assert.ok(dianaUserAccount);
    });

    it("should set Diana's Contribution IDs to an empty collection.", async () => {
      assert.deepEqual(dianaUserAccount.contributionIds, []);
    });

    it("should set Diana's total contributions to zero.", async () => {
      assert.equal(dianaUserAccount.totalContributions, 0);
    });
  });
});
